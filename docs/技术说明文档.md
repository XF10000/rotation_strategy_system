# 中线行业轮动策略技术说明文档

**版本**: 4.1  
**日期**: 2025-08-22  
**更新内容**: 新增季度自动更新机制技术实现

## 1. 系统架构概览

### 1.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   配置管理层     │    │   数据处理层     │    │   策略执行层     │
│                │    │                │    │                │
│ • CSV配置加载   │    │ • 数据获取      │    │ • 信号生成器     │
│ • 参数管理      │    │ • 数据缓存      │    │ • 动态仓位管理   │
│ • 阈值计算      │    │ • 数据预处理    │    │ • 回测引擎      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   分析报告层     │
                    │                │
                    │ • 性能分析      │
                    │ • 报告生成      │
                    │ • 可视化展示    │
                    └─────────────────┘
```

### 1.2 核心模块关系
- **配置管理**: 统一管理所有策略参数和阈值
- **数据处理**: 负责数据获取、缓存和预处理
- **策略执行**: 核心交易逻辑和仓位管理
- **分析报告**: 回测结果分析和可视化

## 2. 核心技术组件

### 2.1 信号生成器 (SignalGenerator)

#### 2.1.1 4维信号系统实现
```python
class SignalGenerator:
    def generate_signal(self, stock_code, date, data):
        """
        4维信号生成逻辑:
        1. 价值过滤器 (硬性条件)
        2. RSI超买超卖 (动态阈值)
        3. MACD动能确认
        4. 布林带+成交量极端信号
        
        返回: (signal_type, signal_strength, dimensions_status)
        """
```

#### 2.1.2 动态RSI阈值系统
- **数据驱动**: 基于历史RSI分布的分位数计算
- **行业差异化**: 124个申万二级行业各自独立阈值
- **自适应更新**: 定期重新计算阈值以适应市场变化

```python
# RSI阈值计算示例
def calculate_dynamic_rsi_thresholds(industry_data):
    """
    基于历史RSI分布计算动态阈值
    - 普通阈值: 20%/80% 分位数
    - 极端阈值: 10%/90% 分位数
    """
    return {
        'oversold_normal': np.percentile(rsi_values, 20),
        'oversold_extreme': np.percentile(rsi_values, 10),
        'overbought_normal': np.percentile(rsi_values, 80),
        'overbought_extreme': np.percentile(rsi_values, 90)
    }
```

### 2.2 🆕 动态仓位管理器 (DynamicPositionManager)

#### 2.2.1 核心设计理念
- **估值驱动**: 基于价值比(`当前价格/DCF估值`)动态调整仓位
- **风险可控**: 通过仓位上限和现金安全垫控制风险
- **资金效率**: 根据机会质量智能配置资金

#### 2.2.2 技术实现
```python
class DynamicPositionManager:
    def __init__(self, config):
        self.value_ratio_thresholds = {
            'extreme_undervalued': 0.60,
            'significantly_undervalued': 0.70,
            'slightly_undervalued': 0.80,
            'fairly_valued': 1.00,
            'slightly_overvalued': 1.20
        }
        
    def calculate_position_size(self, signal_type, stock_code, 
                              current_price, dcf_value, 
                              current_position, available_cash, 
                              total_assets):
        """
        动态仓位计算核心逻辑
        """
        value_ratio = current_price / dcf_value if dcf_value else None
        
        if signal_type == 'BUY':
            return self._calculate_buy_position(
                value_ratio, current_position, 
                available_cash, total_assets
            )
        elif signal_type == 'SELL':
            return self._calculate_sell_position(
                value_ratio, current_position
            )
```

#### 2.2.3 买入仓位策略
```python
def _calculate_buy_position(self, value_ratio, current_position, 
                           available_cash, total_assets):
    """
    基于估值水平和现金情况的买入仓位计算，严格控制单只股票总仓位风险
    """
    # 第一步：基于估值水平确定基础买入金额
    if value_ratio <= 0.60:  # 极度低估
        if current_position > 0:
            # 有持仓：现金充足性检查
            required_cash = current_position * 0.50  # 50%当前持仓价值
            if available_cash >= required_cash:
                base_amount = required_cash
            else:
                base_amount = available_cash * 0.80  # 80%现金
        else:
            # 无持仓：现金充足性检查
            target_amount = total_assets * 0.15  # 15%总资产
            if available_cash >= target_amount:
                base_amount = target_amount
            else:
                base_amount = available_cash * 0.80  # 80%现金
        single_trade_limit = total_assets * 0.15
        
    elif value_ratio <= 0.70:  # 明显低估
        if current_position > 0:
            required_cash = current_position * 0.20  # 20%当前持仓价值
            if available_cash >= required_cash:
                base_amount = required_cash
            else:
                base_amount = available_cash * 0.80  # 80%现金
        else:
            target_amount = total_assets * 0.10  # 10%总资产
            if available_cash >= target_amount:
                base_amount = target_amount
            else:
                base_amount = available_cash * 0.80  # 80%现金
        single_trade_limit = total_assets * 0.10
        
    elif value_ratio <= 0.80:  # 轻度低估
        if current_position > 0:
            required_cash = current_position * 0.10  # 10%当前持仓价值
            if available_cash >= required_cash:
                base_amount = required_cash
            else:
                base_amount = available_cash * 0.80  # 80%现金
        else:
            target_amount = total_assets * 0.05  # 5%总资产
            if available_cash >= target_amount:
                base_amount = target_amount
            else:
                base_amount = available_cash * 0.80  # 80%现金
        single_trade_limit = total_assets * 0.05
    
    # 应用单笔交易限制
    base_amount = min(base_amount, single_trade_limit)
    
    # 第二步：应用总仓位限制（硬性约束）
    max_total_position = total_assets * 0.20  # 单股总仓位上限20%
    current_position_value = current_position  # 当前持仓价值
    
    # 计算剩余可买入空间
    remaining_capacity = max_total_position - current_position_value
    
    # 如果当前持仓已达到或超过20%，则不执行买入
    if remaining_capacity <= 0:
        return 0
    
    # 最终买入金额 = min(基础买入金额, 剩余可买入空间)
    final_amount = min(base_amount, remaining_capacity)
    
    return max(0, final_amount)
```

#### 2.2.4 卖出仓位策略
```python
def _calculate_sell_position(self, value_ratio, current_position):
    """
    基于估值水平的卖出仓位计算
    """
    if value_ratio > 1.20:  # 极度高估
        return current_position * 1.00  # 全部卖出
    elif value_ratio > 1.00:  # 轻度高估
        return current_position * 0.80  # 减仓80%
    elif value_ratio > 0.80:  # 合理区间
        return current_position * 0.50  # 减仓50%
    elif value_ratio > 0.70:  # 轻度低估
        return current_position * 0.20  # 减仓20%
    
    return 0  # 其他情况不卖出
```

### 2.3 🆕 季度自动更新系统

#### 2.3.1 行业映射自动更新器 (IndustryMappingUpdater)

```python
class IndustryMappingUpdater:
    def __init__(self, mapping_file_path='utils/stock_to_industry_map.json'):
        self.mapping_file_path = mapping_file_path
        self.min_stock_count = 5000  # 最小股票数量阈值
        self.max_age_months = 4      # 文件最大年龄（月）
    
    def needs_update(self):
        """
        检查是否需要更新行业映射文件
        检查条件：
        1. 文件不存在
        2. 跨季度更新
        3. 文件过期（超过4个月）
        4. 股票数量异常
        """
        if not os.path.exists(self.mapping_file_path):
            return True, "文件不存在"
        
        # 检查季度变化
        file_time = datetime.fromtimestamp(os.path.getmtime(self.mapping_file_path))
        current_time = datetime.now()
        
        if self._is_quarter_changed(file_time, current_time):
            return True, "跨季度更新"
        
        # 检查文件年龄
        if self._is_file_expired(file_time, current_time):
            return True, "文件过期"
        
        # 检查数据质量
        if not self._validate_stock_count():
            return True, "股票数量异常"
        
        return False, "无需更新"
```

#### 2.3.2 RSI阈值自动更新器 (RSIThresholdUpdater)

```python
class RSIThresholdUpdater:
    def __init__(self, threshold_file_path='sw_rsi_thresholds/output/sw2_rsi_threshold.csv'):
        self.threshold_file_path = threshold_file_path
        self.expected_industry_count = 124  # 申万二级行业数量
        self.max_age_months = 4
    
    def update_if_needed(self):
        """
        智能更新RSI阈值文件
        """
        needs_update, reason = self.needs_update()
        
        if needs_update:
            print(f"检测到需要更新RSI阈值文件: {reason}")
            return self._run_rsi_calculation()
        else:
            print("RSI阈值文件无需更新")
            return True
    
    def _run_rsi_calculation(self):
        """
        执行RSI阈值计算脚本
        """
        script_path = 'sw_rsi_thresholds/run_sw_2021_rsi_calculation.py'
        
        try:
            result = subprocess.run(
                [sys.executable, script_path],
                capture_output=True,
                text=True,
                cwd=os.path.dirname(os.path.abspath(__file__))
            )
            
            if result.returncode == 0:
                print("RSI阈值计算完成")
                return True
            else:
                print(f"RSI阈值计算失败: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"执行RSI阈值计算时出错: {str(e)}")
            return False
```

#### 2.3.3 主程序集成

```python
# main.py 中的集成示例
def ensure_data_freshness():
    """
    确保数据文件的新鲜度
    在回测开始前自动检查和更新必要的数据文件
    """
    print("\n=== 数据文件检查与更新 ===")
    
    # 1. 检查行业映射文件
    industry_updater = IndustryMappingUpdater()
    industry_updater.update_if_needed()
    
    # 2. 检查RSI阈值文件
    rsi_updater = RSIThresholdUpdater()
    rsi_updater.update_if_needed()
    
    print("数据文件检查完成\n")

def main():
    # 启动时自动检查数据文件
    ensure_data_freshness()
    
    # 继续正常的回测流程
    # ...
```

### 2.4 回测引擎 (BacktestEngine)

#### 2.3.1 核心流程
```python
class BacktestEngine:
    def run_backtest(self):
        """
        回测主流程:
        1. 数据加载和预处理
        2. 逐日遍历历史数据
        3. 信号生成和仓位计算
        4. 交易执行和组合更新
        5. 性能分析和报告生成
        """
        for date in self.date_range:
            # 获取当日数据
            daily_data = self.get_daily_data(date)
            
            # 生成交易信号
            signals = self.signal_generator.generate_signals(daily_data)
            
            # 动态仓位管理
            for signal in signals:
                position_size = self.position_manager.calculate_position_size(
                    signal, self.portfolio.get_current_position(signal.stock_code)
                )
                
                # 执行交易
                self.portfolio.execute_trade(signal, position_size)
            
            # 更新组合价值
            self.portfolio.update_portfolio_value(date, daily_data)
```

#### 2.3.2 数据缓存机制
- **智能缓存**: 自动检测数据更新，避免重复下载
- **增量更新**: 只下载缺失的数据，提高效率
- **多源融合**: 整合多个数据源，确保数据完整性

### 2.5 性能分析器 (PerformanceAnalyzer)

#### 2.4.1 关键指标计算
```python
class PerformanceAnalyzer:
    def calculate_metrics(self, portfolio_values, benchmark_values):
        """
        计算关键性能指标:
        - 总收益率、年化收益率
        - 夏普比率、索提诺比率
        - 最大回撤、胜率
        - 基准超额收益
        """
        return {
            'total_return': self._calculate_total_return(portfolio_values),
            'annual_return': self._calculate_annual_return(portfolio_values),
            'sharpe_ratio': self._calculate_sharpe_ratio(portfolio_values),
            'max_drawdown': self._calculate_max_drawdown(portfolio_values),
            'win_rate': self._calculate_win_rate(self.trades),
            'alpha': self._calculate_alpha(portfolio_values, benchmark_values)
        }
```

## 3. 🆕 自动更新机制设计

### 3.1 更新触发条件

#### 3.1.1 季度检查逻辑
```python
def _is_quarter_changed(self, file_time, current_time):
    """
    检查是否跨季度
    """
    file_quarter = (file_time.month - 1) // 3 + 1
    current_quarter = (current_time.month - 1) // 3 + 1
    
    return (file_quarter != current_quarter) or (file_time.year != current_time.year)
```

#### 3.1.2 文件过期检查
```python
def _is_file_expired(self, file_time, current_time):
    """
    检查文件是否过期（超过4个月）
    """
    age_months = (current_time.year - file_time.year) * 12 + (current_time.month - file_time.month)
    return age_months >= self.max_age_months
```

#### 3.1.3 数据质量验证
```python
def _validate_stock_count(self):
    """
    验证股票数量是否正常
    """
    try:
        with open(self.mapping_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            stock_count = len(data.get('mapping', {}))
            return stock_count >= self.min_stock_count
    except:
        return False
```

### 3.2 更新执行策略

#### 3.2.1 行业映射更新流程
1. **数据获取**: 通过akshare API获取最新申万行业分类
2. **成分股获取**: 获取各行业的成分股列表
3. **映射构建**: 构建股票代码到行业的映射关系
4. **文件保存**: 保存为JSON格式到`utils/`目录
5. **验证检查**: 验证生成文件的完整性

#### 3.2.2 RSI阈值更新流程
1. **历史数据获取**: 获取124个申万二级行业104周历史数据
2. **RSI计算**: 计算各行业的14周RSI指标
3. **波动率分层**: 根据RSI标准差进行高中低波动分层
4. **阈值计算**: 计算各层级的动态超买超卖阈值
5. **结果保存**: 保存为CSV格式到`sw_rsi_thresholds/output/`目录

### 3.3 错误处理与容错

```python
class UpdateErrorHandler:
    def __init__(self, max_retries=3):
        self.max_retries = max_retries
    
    def safe_update(self, update_func, fallback_func=None):
        """
        安全更新机制，包含重试和降级策略
        """
        for attempt in range(self.max_retries):
            try:
                return update_func()
            except Exception as e:
                print(f"更新尝试 {attempt + 1} 失败: {str(e)}")
                if attempt == self.max_retries - 1:
                    if fallback_func:
                        print("执行降级策略")
                        return fallback_func()
                    else:
                        print("更新失败，使用现有文件")
                        return False
                time.sleep(2 ** attempt)  # 指数退避
        return False
```

## 4. 数据处理与存储

### 3.1 数据源管理
- **主数据源**: akshare (免费、稳定)
- **备用数据源**: tushare, 新浪财经
- **数据类型**: 股价、成交量、财务数据、行业分类

### 3.2 数据缓存策略
```python
class DataCache:
    def __init__(self, cache_dir='data_cache'):
        self.cache_dir = cache_dir
        self.cache_expiry = 24 * 3600  # 24小时过期
    
    def get_cached_data(self, key):
        """获取缓存数据，自动检查过期时间"""
        cache_file = os.path.join(self.cache_dir, f"{key}.pkl")
        if os.path.exists(cache_file):
            mtime = os.path.getmtime(cache_file)
            if time.time() - mtime < self.cache_expiry:
                return pickle.load(open(cache_file, 'rb'))
        return None
```

### 4.3 🆕 行业分类映射自动化
- **申万二级行业**: 124个细分行业，5,209只股票
- **季度自动更新**: 每季度自动检查并更新行业映射
- **本地缓存优化**: 避免频繁网络查询，提升性能
- **智能匹配**: 基于股票代码和名称的智能匹配算法
- **数据验证**: 自动验证数据完整性和准确性

## 5. 配置管理系统

### 4.1 CSV配置文件
- **回测设置** (`Becktest_settings.csv`): 回测时间范围、初始资金等
- **组合配置** (`portfolio_config.csv`): 股票池和权重配置
- **RSI阈值** (`industry_rsi_thresholds.csv`): 各行业动态RSI阈值

### 4.2 配置加载器
```python
class CSVConfigLoader:
    def load_backtest_config(self):
        """加载回测配置"""
        config = pd.read_csv('Input/Becktest_settings.csv')
        return {
            'start_date': config['start_date'].iloc[0],
            'end_date': config['end_date'].iloc[0],
            'initial_capital': float(config['initial_capital'].iloc[0])
        }
```

## 6. 报告生成系统

### 5.1 HTML报告
- **交互式图表**: 使用Plotly生成动态图表
- **K线图标注**: 标记买卖点和技术指标
- **多维度分析**: 4个信号维度的详细状态展示

### 5.2 CSV详细报告
- **交易明细**: 每笔交易的完整记录
- **信号状态**: 触发交易时4个维度的详细状态
- **🆕 仓位决策**: 动态仓位管理的决策依据
- **🆕 估值分析**: 价值比和DCF估值数据

### 5.3 报告模板
```html
<!-- HTML报告模板示例 -->
<div class="signal-analysis">
    <h3>4维信号分析</h3>
    <div class="dimension">
        <span class="label">价值过滤器:</span>
        <span class="status {{value_filter_status}}">{{value_ratio}}</span>
    </div>
    <div class="dimension">
        <span class="label">RSI信号:</span>
        <span class="status {{rsi_status}}">{{rsi_value}}</span>
    </div>
    <!-- 其他维度... -->
</div>
```

## 7. 🆕 动态仓位管理技术细节

### 6.1 风险控制机制
```python
class RiskController:
    def __init__(self):
        self.max_single_position = 0.20  # 单股总仓位上限20%（核心约束）
        self.max_single_trade_ratios = {  # 单笔交易上限
            'extreme_undervalued': 0.15,  # 极度低估：15%总资产
            'significantly_undervalued': 0.10,  # 明显低估：10%总资产
            'slightly_undervalued': 0.05   # 轻度低估：5%总资产
        }
        self.min_cash_reserve = 0.05     # 最低5%现金
        self.min_trade_amount = 10000    # 最小交易金额
        
    def validate_trade(self, trade_amount, current_portfolio, stock_code):
        """交易前风险检查"""
        # 检查现金充足性
        if trade_amount > current_portfolio.available_cash:
            return False, "现金不足"
            
        # 检查单股总仓位上限（核心约束）
        current_position_value = current_portfolio.get_position_value(stock_code)
        new_total_position_ratio = (current_position_value + trade_amount) / current_portfolio.total_value
        
        if new_total_position_ratio > self.max_single_position:
            return False, f"超出单股总仓位上限20%，当前将达到{new_total_position_ratio:.1%}"
            
        # 检查现金安全垫
        remaining_cash = current_portfolio.available_cash - trade_amount
        if remaining_cash < current_portfolio.total_value * self.min_cash_reserve:
            return False, "违反现金安全垫要求"
            
        return True, "通过风险检查"
```

### 6.2 交易执行优化
- **最小交易单位**: 100股整数倍，符合A股交易规则
- **滑点控制**: 考虑市场冲击成本
- **分批执行**: 大额交易分批执行，降低市场冲击

### 6.3 估值数据处理
```python
class ValuationProcessor:
    def get_dcf_value(self, stock_code, date):
        """获取DCF估值数据"""
        # 优先使用实时DCF数据
        dcf_value = self.dcf_data_source.get_value(stock_code, date)
        
        if dcf_value is None:
            # 回退到历史估值数据
            dcf_value = self.estimate_dcf_from_historical(stock_code, date)
            
        return dcf_value
    
    def calculate_value_ratio(self, current_price, dcf_value):
        """计算价值比率"""
        if dcf_value and dcf_value > 0:
            return current_price / dcf_value
        return None
```

## 8. 性能优化

### 8.1 🆕 启动性能优化
- **本地缓存**: 行业映射文件本地缓存，避免网络查询
- **智能更新**: 仅在必要时更新，避免不必要的计算
- **并行处理**: RSI阈值计算支持并行处理
- **增量更新**: 支持增量数据更新机制

### 8.2 计算优化

### 7.1 计算优化
- **向量化计算**: 使用numpy和pandas的向量化操作
- **并行处理**: 多进程处理大量股票数据
- **内存管理**: 及时释放不需要的数据，控制内存使用

### 7.2 I/O优化
- **批量读写**: 减少文件I/O次数
- **压缩存储**: 使用pickle压缩存储缓存数据
- **异步加载**: 异步加载非关键数据

## 9. 测试与验证

### 8.1 单元测试
- **信号生成测试**: 验证4维信号逻辑正确性
- **🆕 仓位管理测试**: 验证动态仓位计算准确性
- **数据处理测试**: 验证数据获取和处理逻辑

### 8.2 集成测试
- **端到端回测**: 完整回测流程测试
- **性能基准测试**: 与买入持有策略对比
- **边界条件测试**: 极端市场条件下的系统稳定性

## 10. 部署与运维

### 9.1 环境要求
```
Python >= 3.8
pandas >= 1.3.0
numpy >= 1.21.0
akshare >= 1.8.0
plotly >= 5.0.0
```

### 9.2 运行方式
```bash
# 标准回测
python main.py

# 自定义配置回测
python main.py --config custom_config.csv

# 批量验证
python batch_validate_portfolio.py
```

### 9.3 监控与日志
- **详细日志**: 记录所有关键操作和决策过程
- **错误处理**: 完善的异常处理和恢复机制
- **性能监控**: 监控回测执行时间和资源使用

## 11. 版本更新记录

### V4.1 (2025-08-22) - 季度自动更新系统
**新增功能:**
- 行业映射文件季度自动更新机制
- RSI动态阈值文件季度自动更新机制
- 智能更新触发条件（跨季度、文件过期、数据异常）
- 完善的错误处理和容错机制

**性能提升:**
- 启动速度大幅优化（从数分钟到秒级）
- 本地缓存5,209只股票行业映射
- 避免频繁网络查询，提升系统稳定性

**技术改进:**
- 新增`IndustryMappingUpdater`和`RSIThresholdUpdater`模块
- 集成到主程序启动流程
- 完善的数据验证和质量检查

### V4.0 (2025-08-11) - 动态仓位管理系统

### V4.0 (2025-08-11) - 动态仓位管理系统
**新增功能:**
- 基于价值比的动态仓位管理系统
- 估值驱动的买卖决策逻辑
- 完善的风险控制机制
- 分红配股事件处理

**技术改进:**
- 重构仓位管理模块
- 优化交易执行逻辑
- 增强报告生成功能
- 完善测试覆盖

**性能提升:**
- 提高资金使用效率
- 降低交易风险
- 增强策略适应性

### V3.0 (2025-08-09) - 多维信号系统
- 实现4维信号决策框架
- 动态RSI阈值系统
- 行业差异化处理

---

**文档维护**: 本技术文档将随着系统功能迭代持续更新，确保技术实现与需求保持一致。