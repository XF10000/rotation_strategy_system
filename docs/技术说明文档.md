# 中线行业轮动策略技术说明文档

**版本**: 4.0  
**日期**: 2025-08-11  
**更新内容**: 新增动态仓位管理系统技术实现

## 1. 系统架构概览

### 1.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   配置管理层     │    │   数据处理层     │    │   策略执行层     │
│                │    │                │    │                │
│ • CSV配置加载   │    │ • 数据获取      │    │ • 信号生成器     │
│ • 参数管理      │    │ • 数据缓存      │    │ • 动态仓位管理   │
│ • 阈值计算      │    │ • 数据预处理    │    │ • 回测引擎      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   分析报告层     │
                    │                │
                    │ • 性能分析      │
                    │ • 报告生成      │
                    │ • 可视化展示    │
                    └─────────────────┘
```

### 1.2 核心模块关系
- **配置管理**: 统一管理所有策略参数和阈值
- **数据处理**: 负责数据获取、缓存和预处理
- **策略执行**: 核心交易逻辑和仓位管理
- **分析报告**: 回测结果分析和可视化

## 2. 核心技术组件

### 2.1 信号生成器 (SignalGenerator)

#### 2.1.1 4维信号系统实现
```python
class SignalGenerator:
    def generate_signal(self, stock_code, date, data):
        """
        4维信号生成逻辑:
        1. 价值过滤器 (硬性条件)
        2. RSI超买超卖 (动态阈值)
        3. MACD动能确认
        4. 布林带+成交量极端信号
        
        返回: (signal_type, signal_strength, dimensions_status)
        """
```

#### 2.1.2 动态RSI阈值系统
- **数据驱动**: 基于历史RSI分布的分位数计算
- **行业差异化**: 124个申万二级行业各自独立阈值
- **自适应更新**: 定期重新计算阈值以适应市场变化

```python
# RSI阈值计算示例
def calculate_dynamic_rsi_thresholds(industry_data):
    """
    基于历史RSI分布计算动态阈值
    - 普通阈值: 20%/80% 分位数
    - 极端阈值: 10%/90% 分位数
    """
    return {
        'oversold_normal': np.percentile(rsi_values, 20),
        'oversold_extreme': np.percentile(rsi_values, 10),
        'overbought_normal': np.percentile(rsi_values, 80),
        'overbought_extreme': np.percentile(rsi_values, 90)
    }
```

### 2.2 🆕 动态仓位管理器 (DynamicPositionManager)

#### 2.2.1 核心设计理念
- **估值驱动**: 基于价值比(`当前价格/DCF估值`)动态调整仓位
- **风险可控**: 通过仓位上限和现金安全垫控制风险
- **资金效率**: 根据机会质量智能配置资金

#### 2.2.2 技术实现
```python
class DynamicPositionManager:
    def __init__(self, config):
        self.value_ratio_thresholds = {
            'extreme_undervalued': 0.60,
            'significantly_undervalued': 0.70,
            'slightly_undervalued': 0.80,
            'fairly_valued': 1.00,
            'slightly_overvalued': 1.20
        }
        
    def calculate_position_size(self, signal_type, stock_code, 
                              current_price, dcf_value, 
                              current_position, available_cash, 
                              total_assets):
        """
        动态仓位计算核心逻辑
        """
        value_ratio = current_price / dcf_value if dcf_value else None
        
        if signal_type == 'BUY':
            return self._calculate_buy_position(
                value_ratio, current_position, 
                available_cash, total_assets
            )
        elif signal_type == 'SELL':
            return self._calculate_sell_position(
                value_ratio, current_position
            )
```

#### 2.2.3 买入仓位策略
```python
def _calculate_buy_position(self, value_ratio, current_position, 
                           available_cash, total_assets):
    """
    基于估值水平和现金情况的买入仓位计算，严格控制单只股票总仓位风险
    """
    # 第一步：基于估值水平确定基础买入金额
    if value_ratio <= 0.60:  # 极度低估
        if current_position > 0:
            # 有持仓：现金充足性检查
            required_cash = current_position * 0.50  # 50%当前持仓价值
            if available_cash >= required_cash:
                base_amount = required_cash
            else:
                base_amount = available_cash * 0.80  # 80%现金
        else:
            # 无持仓：现金充足性检查
            target_amount = total_assets * 0.15  # 15%总资产
            if available_cash >= target_amount:
                base_amount = target_amount
            else:
                base_amount = available_cash * 0.80  # 80%现金
        single_trade_limit = total_assets * 0.15
        
    elif value_ratio <= 0.70:  # 明显低估
        if current_position > 0:
            required_cash = current_position * 0.20  # 20%当前持仓价值
            if available_cash >= required_cash:
                base_amount = required_cash
            else:
                base_amount = available_cash * 0.80  # 80%现金
        else:
            target_amount = total_assets * 0.10  # 10%总资产
            if available_cash >= target_amount:
                base_amount = target_amount
            else:
                base_amount = available_cash * 0.80  # 80%现金
        single_trade_limit = total_assets * 0.10
        
    elif value_ratio <= 0.80:  # 轻度低估
        if current_position > 0:
            required_cash = current_position * 0.10  # 10%当前持仓价值
            if available_cash >= required_cash:
                base_amount = required_cash
            else:
                base_amount = available_cash * 0.80  # 80%现金
        else:
            target_amount = total_assets * 0.05  # 5%总资产
            if available_cash >= target_amount:
                base_amount = target_amount
            else:
                base_amount = available_cash * 0.80  # 80%现金
        single_trade_limit = total_assets * 0.05
    
    # 应用单笔交易限制
    base_amount = min(base_amount, single_trade_limit)
    
    # 第二步：应用总仓位限制（硬性约束）
    max_total_position = total_assets * 0.20  # 单股总仓位上限20%
    current_position_value = current_position  # 当前持仓价值
    
    # 计算剩余可买入空间
    remaining_capacity = max_total_position - current_position_value
    
    # 如果当前持仓已达到或超过20%，则不执行买入
    if remaining_capacity <= 0:
        return 0
    
    # 最终买入金额 = min(基础买入金额, 剩余可买入空间)
    final_amount = min(base_amount, remaining_capacity)
    
    return max(0, final_amount)
```

#### 2.2.4 卖出仓位策略
```python
def _calculate_sell_position(self, value_ratio, current_position):
    """
    基于估值水平的卖出仓位计算
    """
    if value_ratio > 1.20:  # 极度高估
        return current_position * 1.00  # 全部卖出
    elif value_ratio > 1.00:  # 轻度高估
        return current_position * 0.80  # 减仓80%
    elif value_ratio > 0.80:  # 合理区间
        return current_position * 0.50  # 减仓50%
    elif value_ratio > 0.70:  # 轻度低估
        return current_position * 0.20  # 减仓20%
    
    return 0  # 其他情况不卖出
```

### 2.3 回测引擎 (BacktestEngine)

#### 2.3.1 核心流程
```python
class BacktestEngine:
    def run_backtest(self):
        """
        回测主流程:
        1. 数据加载和预处理
        2. 逐日遍历历史数据
        3. 信号生成和仓位计算
        4. 交易执行和组合更新
        5. 性能分析和报告生成
        """
        for date in self.date_range:
            # 获取当日数据
            daily_data = self.get_daily_data(date)
            
            # 生成交易信号
            signals = self.signal_generator.generate_signals(daily_data)
            
            # 动态仓位管理
            for signal in signals:
                position_size = self.position_manager.calculate_position_size(
                    signal, self.portfolio.get_current_position(signal.stock_code)
                )
                
                # 执行交易
                self.portfolio.execute_trade(signal, position_size)
            
            # 更新组合价值
            self.portfolio.update_portfolio_value(date, daily_data)
```

#### 2.3.2 数据缓存机制
- **智能缓存**: 自动检测数据更新，避免重复下载
- **增量更新**: 只下载缺失的数据，提高效率
- **多源融合**: 整合多个数据源，确保数据完整性

### 2.4 性能分析器 (PerformanceAnalyzer)

#### 2.4.1 关键指标计算
```python
class PerformanceAnalyzer:
    def calculate_metrics(self, portfolio_values, benchmark_values):
        """
        计算关键性能指标:
        - 总收益率、年化收益率
        - 夏普比率、索提诺比率
        - 最大回撤、胜率
        - 基准超额收益
        """
        return {
            'total_return': self._calculate_total_return(portfolio_values),
            'annual_return': self._calculate_annual_return(portfolio_values),
            'sharpe_ratio': self._calculate_sharpe_ratio(portfolio_values),
            'max_drawdown': self._calculate_max_drawdown(portfolio_values),
            'win_rate': self._calculate_win_rate(self.trades),
            'alpha': self._calculate_alpha(portfolio_values, benchmark_values)
        }
```

## 3. 数据处理与存储

### 3.1 数据源管理
- **主数据源**: akshare (免费、稳定)
- **备用数据源**: tushare, 新浪财经
- **数据类型**: 股价、成交量、财务数据、行业分类

### 3.2 数据缓存策略
```python
class DataCache:
    def __init__(self, cache_dir='data_cache'):
        self.cache_dir = cache_dir
        self.cache_expiry = 24 * 3600  # 24小时过期
    
    def get_cached_data(self, key):
        """获取缓存数据，自动检查过期时间"""
        cache_file = os.path.join(self.cache_dir, f"{key}.pkl")
        if os.path.exists(cache_file):
            mtime = os.path.getmtime(cache_file)
            if time.time() - mtime < self.cache_expiry:
                return pickle.load(open(cache_file, 'rb'))
        return None
```

### 3.3 行业分类映射
- **申万二级行业**: 124个细分行业
- **多源映射**: 整合多个数据源的行业分类
- **智能匹配**: 基于股票代码和名称的智能匹配算法

## 4. 配置管理系统

### 4.1 CSV配置文件
- **回测设置** (`Becktest_settings.csv`): 回测时间范围、初始资金等
- **组合配置** (`portfolio_config.csv`): 股票池和权重配置
- **RSI阈值** (`industry_rsi_thresholds.csv`): 各行业动态RSI阈值

### 4.2 配置加载器
```python
class CSVConfigLoader:
    def load_backtest_config(self):
        """加载回测配置"""
        config = pd.read_csv('Input/Becktest_settings.csv')
        return {
            'start_date': config['start_date'].iloc[0],
            'end_date': config['end_date'].iloc[0],
            'initial_capital': float(config['initial_capital'].iloc[0])
        }
```

## 5. 报告生成系统

### 5.1 HTML报告
- **交互式图表**: 使用Plotly生成动态图表
- **K线图标注**: 标记买卖点和技术指标
- **多维度分析**: 4个信号维度的详细状态展示

### 5.2 CSV详细报告
- **交易明细**: 每笔交易的完整记录
- **信号状态**: 触发交易时4个维度的详细状态
- **🆕 仓位决策**: 动态仓位管理的决策依据
- **🆕 估值分析**: 价值比和DCF估值数据

### 5.3 报告模板
```html
<!-- HTML报告模板示例 -->
<div class="signal-analysis">
    <h3>4维信号分析</h3>
    <div class="dimension">
        <span class="label">价值过滤器:</span>
        <span class="status {{value_filter_status}}">{{value_ratio}}</span>
    </div>
    <div class="dimension">
        <span class="label">RSI信号:</span>
        <span class="status {{rsi_status}}">{{rsi_value}}</span>
    </div>
    <!-- 其他维度... -->
</div>
```

## 6. 🆕 动态仓位管理技术细节

### 6.1 风险控制机制
```python
class RiskController:
    def __init__(self):
        self.max_single_position = 0.20  # 单股总仓位上限20%（核心约束）
        self.max_single_trade_ratios = {  # 单笔交易上限
            'extreme_undervalued': 0.15,  # 极度低估：15%总资产
            'significantly_undervalued': 0.10,  # 明显低估：10%总资产
            'slightly_undervalued': 0.05   # 轻度低估：5%总资产
        }
        self.min_cash_reserve = 0.05     # 最低5%现金
        self.min_trade_amount = 10000    # 最小交易金额
        
    def validate_trade(self, trade_amount, current_portfolio, stock_code):
        """交易前风险检查"""
        # 检查现金充足性
        if trade_amount > current_portfolio.available_cash:
            return False, "现金不足"
            
        # 检查单股总仓位上限（核心约束）
        current_position_value = current_portfolio.get_position_value(stock_code)
        new_total_position_ratio = (current_position_value + trade_amount) / current_portfolio.total_value
        
        if new_total_position_ratio > self.max_single_position:
            return False, f"超出单股总仓位上限20%，当前将达到{new_total_position_ratio:.1%}"
            
        # 检查现金安全垫
        remaining_cash = current_portfolio.available_cash - trade_amount
        if remaining_cash < current_portfolio.total_value * self.min_cash_reserve:
            return False, "违反现金安全垫要求"
            
        return True, "通过风险检查"
```

### 6.2 交易执行优化
- **最小交易单位**: 100股整数倍，符合A股交易规则
- **滑点控制**: 考虑市场冲击成本
- **分批执行**: 大额交易分批执行，降低市场冲击

### 6.3 估值数据处理
```python
class ValuationProcessor:
    def get_dcf_value(self, stock_code, date):
        """获取DCF估值数据"""
        # 优先使用实时DCF数据
        dcf_value = self.dcf_data_source.get_value(stock_code, date)
        
        if dcf_value is None:
            # 回退到历史估值数据
            dcf_value = self.estimate_dcf_from_historical(stock_code, date)
            
        return dcf_value
    
    def calculate_value_ratio(self, current_price, dcf_value):
        """计算价值比率"""
        if dcf_value and dcf_value > 0:
            return current_price / dcf_value
        return None
```

## 7. 性能优化

### 7.1 计算优化
- **向量化计算**: 使用numpy和pandas的向量化操作
- **并行处理**: 多进程处理大量股票数据
- **内存管理**: 及时释放不需要的数据，控制内存使用

### 7.2 I/O优化
- **批量读写**: 减少文件I/O次数
- **压缩存储**: 使用pickle压缩存储缓存数据
- **异步加载**: 异步加载非关键数据

## 8. 测试与验证

### 8.1 单元测试
- **信号生成测试**: 验证4维信号逻辑正确性
- **🆕 仓位管理测试**: 验证动态仓位计算准确性
- **数据处理测试**: 验证数据获取和处理逻辑

### 8.2 集成测试
- **端到端回测**: 完整回测流程测试
- **性能基准测试**: 与买入持有策略对比
- **边界条件测试**: 极端市场条件下的系统稳定性

## 9. 部署与运维

### 9.1 环境要求
```
Python >= 3.8
pandas >= 1.3.0
numpy >= 1.21.0
akshare >= 1.8.0
plotly >= 5.0.0
```

### 9.2 运行方式
```bash
# 标准回测
python main.py

# 自定义配置回测
python main.py --config custom_config.csv

# 批量验证
python batch_validate_portfolio.py
```

### 9.3 监控与日志
- **详细日志**: 记录所有关键操作和决策过程
- **错误处理**: 完善的异常处理和恢复机制
- **性能监控**: 监控回测执行时间和资源使用

## 10. 版本更新记录

### V4.0 (2025-08-11) - 动态仓位管理系统
**新增功能:**
- 基于价值比的动态仓位管理系统
- 估值驱动的买卖决策逻辑
- 完善的风险控制机制
- 分红配股事件处理

**技术改进:**
- 重构仓位管理模块
- 优化交易执行逻辑
- 增强报告生成功能
- 完善测试覆盖

**性能提升:**
- 提高资金使用效率
- 降低交易风险
- 增强策略适应性

### V3.0 (2025-08-09) - 多维信号系统
- 实现4维信号决策框架
- 动态RSI阈值系统
- 行业差异化处理

---

**文档维护**: 本技术文档将随着系统功能迭代持续更新，确保技术实现与需求保持一致。