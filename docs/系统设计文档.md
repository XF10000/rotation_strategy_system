# 中线轮动策略系统设计文档

## 1. 项目概述

基于中线轮动完整策略 v1.0 的量化交易系统，实现股票池轮动策略的信号生成和回测功能。

### 核心特性
- 周线级别技术分析
- 4维度信号评分系统（趋势过滤器 + 3选2机制）
- 10%固定仓位轮动
- 完整回测系统
- **智能数据缓存系统**：支持增量数据获取，避免重复网络请求
- **行业信息缓存优化**：内存缓存行业分类信息，大幅提升回测性能

## 2. 系统架构

### 2.1 模块划分

```
轮动策略系统/
├── data/                    # 数据模块
│   ├── data_fetcher.py     # 数据获取（akshare等）
│   ├── data_processor.py   # 数据预处理
│   ├── data_storage.py     # 智能数据存储管理（支持增量缓存）
│   └── cache_manager.py    # 缓存管理器（数据缓存策略）
├── indicators/              # 技术指标模块
│   ├── trend.py            # 趋势指标（EMA等）
│   ├── momentum.py         # 动量指标（RSI、MACD）
│   ├── volatility.py       # 波动率指标（布林带）
│   └── divergence.py       # 背离检测
├── strategy/               # 策略核心
│   ├── signal_generator.py # 信号生成器（集成行业信息缓存）
│   ├── position_manager.py # 仓位管理
│   └── rotation_engine.py  # 轮动引擎
├── backtest/               # 回测系统
│   ├── backtest_engine.py  # 回测引擎
│   ├── performance.py      # 绩效分析
│   └── visualization.py    # 结果可视化
├── config/                 # 配置管理
│   ├── settings.py         # 系统配置
│   ├── stock_pool.py       # 股票池配置
│   ├── backtest_configs.py # 回测配置预设
│   ├── csv_config_loader.py # CSV配置加载器
│   └── industry_rsi_loader.py # 行业RSI配置加载器
├── Input/                  # CSV配置文件目录
│   ├── portfolio_config.csv # 投资组合配置
│   ├── Becktest_settings.csv # 回测设置配置
│   └── industry_rsi_thresholds.csv # 行业RSI阈值配置
├── tests/                  # 单元测试
├── docs/                   # 文档目录
├── logs/                   # 日志目录
├── data_cache/             # 数据缓存目录
└── main.py                 # 主程序入口
```

### 2.2 数据流设计

```
CSV配置文件 → 配置加载验证 → 股票池初始化 → 智能数据获取(缓存检查+增量获取) → 数据预处理 → 技术指标计算 → 信号生成(行业信息缓存) → 轮动决策 → 回测引擎 → 绩效分析 → 结果输出
```

### 2.3 CSV配置管理架构

#### 2.3.1 配置文件层
- **投资组合配置**：`Input/portfolio_config.csv` - 股票代码、权重、行业、DCF估值
- **回测设置配置**：`Input/Becktest_settings.csv` - 总资金、日期范围等参数
- **行业RSI配置**：`Input/industry_rsi_thresholds.csv` - 行业特定RSI阈值

#### 2.3.2 配置加载层
- **CSV配置加载器**：`config/csv_config_loader.py` - 统一的CSV文件读取和解析
- **配置验证器**：数据完整性验证、格式检查、逻辑验证
- **配置合并器**：将CSV配置与默认参数合并

#### 2.3.3 配置流程
```
CSV文件读取 → 编码处理(UTF-8) → 数据验证 → 类型转换 → 配置合并 → 配置对象创建
```

### 2.3 缓存系统架构

#### 2.3.1 数据缓存层
- **本地文件缓存**：按股票代码+时间范围缓存历史数据
- **增量更新**：智能检测缓存空缺，仅获取缺失数据
- **缓存策略**：支持日线/周线数据分别缓存

#### 2.3.2 行业信息缓存层
- **内存缓存**：单次回测内行业信息不重复获取
- **行业规则缓存**：缓存行业特定的RSI阈值和信号规则
- **性能提升**：从数千次网络请求降低到每股票仅一次

## 3. 核心算法

### 3.1 信号生成规则

**4维度评分系统**：
1. **趋势过滤器（硬性前提）**
   - 卖出：收盘价 > 20周EMA 且 EMA向上
   - 买入：收盘价 < 20周EMA 且 EMA向下

2. **超买/超卖**
   - 卖出：14周RSI > 70 且出现顶背离
   - 买入：14周RSI < 30 且出现底背离

3. **动能确认**
   - 卖出：MACD红色柱体连续2根缩短 或 MACD柱体已为绿色 或 DIF死叉DEA
   - 买入：MACD绿色柱体连续2根缩短 或 MACD柱体已为红色 或 DIF金叉DEA

4. **极端价格 + 量能**
   - 卖出：收盘价 ≥ 布林上轨 且本周量 ≥ 4周均量 ×1.3
   - 买入：收盘价 ≤ 布林下轨 且本周量 ≥ 4周均量 ×0.8

**触发逻辑**：趋势过滤器 + 其余3条中至少满足2条

### 3.2 技术指标历史数据要求

**⚠️ 重要提醒**: 技术指标计算需要足够的历史数据，否则会出现NaN值或固定值，影响信号生成的准确性。

#### 3.2.1 各指标最小历史数据要求

| 技术指标 | 最小历史数据量 | 推荐数据量 | 说明 |
|---------|---------------|-----------|------|
| **RSI(14)** | 14周 | 20周 | 需要14个价格变化数据点计算平均涨跌幅 |
| **MACD(12,26,9)** | 26周 | 40周 | 慢线EMA26需要26周，信号线DEA需要额外9周 |
| **EMA(20)** | 20周 | 25周 | 指数移动平均线需要对应周期数据 |
| **EMA(60)** | 60周 | 65周 | 长期均线需要更多历史数据 |
| **布林带(20,2)** | 20周 | 25周 | 基于20周移动平均线和标准差 |
| **成交量均线(4周)** | 4周 | 8周 | 4周成交量移动平均 |

#### 3.2.2 系统实现策略

**数据获取扩展**:
```python
# backtest_engine.py - run_backtest()方法中
# 向前扩展历史数据窗口，确保技术指标计算准确
history_buffer_weeks = 40  # 足够覆盖MACD等长周期指标
expanded_start_date = start_date - timedelta(weeks=history_buffer_weeks)
```

**关键实现要点**:
1. **预加载历史数据**: 回测开始前向前扩展40周历史数据
2. **指标计算验证**: 确保所有指标在回测期间无NaN值
3. **数据窗口管理**: 使用滑动窗口保持足够的历史数据
4. **缓存策略**: 缓存扩展的历史数据，避免重复获取

#### 3.2.3 常见问题及解决方案

**问题1**: RSI在回测初期显示固定值
- **原因**: 历史数据不足，无法计算有效的平均涨跌幅
- **解决**: 确保RSI计算前至少有20周历史数据

**问题2**: MACD在前期显示NaN或异常值
- **原因**: EMA26需要26周数据，DEA信号线需要额外9周
- **解决**: 预加载至少40周历史数据

**问题3**: 布林带上下轨异常
- **原因**: 20周移动平均线和标准差计算数据不足
- **解决**: 确保有足够的价格历史数据计算标准差

#### 3.2.4 数据质量检查

**自动验证机制**:
```python
# 在技术指标计算后进行数据质量检查
def validate_indicators(df):
    indicators = ['rsi_14w', 'macd_dif', 'macd_dea', 'bb_upper', 'bb_lower']
    for indicator in indicators:
        nan_count = df[indicator].isna().sum()
        if nan_count > 0:
            logger.warning(f"{indicator} 包含 {nan_count} 个NaN值")
```

### 3.3 背离检测算法

```python
def rsi_divergence(df, direction='top'):
    price = df['close']
    rsi   = df['rsi14']
    n = 13   # 回溯13周
    if direction == 'top':
        return price.iloc[-1] == price.rolling(n).max().iloc[-1] and \
               rsi.iloc[-1]  < rsi.rolling(n).max().iloc[-1]
    else:  # bottom
        return price.iloc[-1] == price.rolling(n).min().iloc[-1] and \
               rsi.iloc[-1]  > rsi.rolling(n).min().iloc[-1]
```

## 4. 技术选型

- **数据获取**: akshare + 备用数据源
- **数据处理**: pandas + numpy
- **数据缓存**: pickle + JSON文件存储 + 内存字典缓存
- **缓存策略**: 按股票代码+时间范围的文件缓存 + 行业信息内存缓存
- **技术指标**: pandas_ta + 自定义实现
- **回测框架**: 自建轻量级框架
- **可视化**: matplotlib + plotly
- **配置管理**: YAML文件
- **日志**: logging模块

## 5. 实现计划

### 第一阶段：基础框架
1. 项目目录结构搭建
2. 配置管理系统
3. 数据获取模块
4. 基础技术指标计算

### 第二阶段：核心功能
1. 背离检测算法
2. 信号生成器
3. 轮动引擎
4. 基础回测框架

### 第三阶段：完善功能
1. 绩效分析模块
2. 可视化输出
3. 参数优化
4. 单元测试

### 第四阶段：优化提升
1. 多数据源支持
2. 实时监控
3. 风险管理增强
4. 文档完善

## 6. 关键设计原则

### 6.1 模块化设计
- 每个技术指标独立模块，便于测试和优化
- 策略逻辑与数据获取分离
- 回测系统独立，支持不同策略测试

### 6.2 数据管理
- **智能缓存系统**：支持本地文件缓存和内存缓存，避免重复获取
- **增量数据获取**：智能检测缓存空缺，仅获取缺失数据
- **行业信息优化**：内存缓存行业分类信息，大幅提升性能
- 数据验证和清洗机制
- 支持多数据源切换

### 6.3 回测系统核心功能
- 历史数据回放
- 交易成本计算（手续费、印花税、滑点）
- 多维度绩效指标（收益率、夏普比率、最大回撤等）
- 信号准确率统计

### 6.4 收益率计算方法

系统采用统一的投资组合市值变化法计算策略收益率和基准收益率，确保比较的公平性和准确性。

#### 6.4.1 核心计算公式

```
收益率 = (结束日总市值 - 开始日总市值) / 开始日总市值
```

#### 6.4.2 总市值计算

```
某日的总市值 = 持仓股票总市值 + 现金余额
持仓股票总市值 = Σ(持仓股数 × 当日股票收盘价)
```

#### 6.4.3 策略收益率实现

**代码位置**: `backtest/backtest_engine.py` - `get_backtest_results()` 方法

**实现逻辑**:
1. **日市值记录**: 每日记录投资组合总市值（`portfolio_history`）
2. **市值计算**: 通过 `PortfolioManager.get_total_value()` 方法计算
   ```python
   # portfolio_manager.py - get_total_value()方法
   total_value = self.cash  # 现金作为起始值
   
   # 累加所有股票市值
   total_value += shares * current_prices[stock_code]
   ```
3. **收益率计算**: 在 `BacktestEngine.get_backtest_results()` 方法中
   ```python
   # backtest_engine.py - get_backtest_results()方法
   total_return = (final_value - initial_value) / initial_value
   ```

#### 6.4.4 基准收益率实现

**代码位置**: `backtest/backtest_engine.py` - `_calculate_buy_and_hold_benchmark()` 方法

**实现逻辑**:
1. **权重读取**: 从 `Input/portfolio_config.csv` 读取初始投资组合权重
2. **投资组合构建**: 按权重分配初始资金，计算各股票持仓股数
3. **市值计算**: 在 `_calculate_buy_and_hold_benchmark()` 方法中
   ```python
   # 开始市值 = Σ(股数 × 开始价格) + 现金
   start_total_value = Σ(shares × start_price) + cash_amount
   
   # 结束市值 = Σ(股数 × 结束价格) + 现金  
   end_total_value = Σ(shares × end_price) + cash_amount
   ```
4. **收益率计算**: 使用与策略收益率相同的公式
   ```python
   total_return = (end_total_value - start_total_value) / start_total_value
   ```

#### 6.4.5 特殊情况处理

**100%现金投资组合**:
- 自动检测股票权重 ≤ 1% 的情况
- 策略收益率和基准收益率均返回 0%
- 确保现金持有期间的收益率计算准确性

#### 6.4.6 年化收益率计算

```python
# 复合年增长率 (CAGR) 计算 - 在 get_backtest_results() 方法中
annual_return = (final_value / initial_value) ** (365.25 / days) - 1
```

#### 6.4.7 计算一致性保证

- ✅ **统一公式**: 策略和基准都使用投资组合市值变化法
- ✅ **现金包含**: 总市值包含现金余额，反映真实投资组合价值
- ✅ **权重考虑**: 基准收益率基于实际投资组合权重，而非简单等权重
- ✅ **时间对齐**: 策略和基准使用相同的时间窗口和数据源

## 7. 风险控制

- 单次最大10%仓位限制
- 基本面突变优先于技术信号
- 人工再确认机制（DCF估值对比）
- 定期策略回顾和参数调整

## 8. 扩展性考虑

- 支持新增股票池
- 支持新增技术指标
- 支持多策略并行
- 支持参数自适应优化

---

**创建时间**: 2024年12月
**最后更新**: 2025年1月
**版本**: v2.0
**状态**: 已实现核心功能，缓存系统已优化